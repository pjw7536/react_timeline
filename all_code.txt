
----- C:\Users\pjw75\Desktop\react-prc\src\api\historyAPI.js -----

// API 요청을 위한 함수들 정의. 실제 백엔드 API와 통신할 때 사용합니다.

const API_BASE_URL = "http://127.0.0.1:8000"; // 서버 주소. 실제 운영시 변경 필요!

// "라인 목록"을 가져오는 API
export const fetchLines = async () => {
  const response = await fetch(`${API_BASE_URL}/lines`);
  if (!response.ok) throw new Error("Failed to fetch lines");
  return response.json();
};

// 선택한 라인의 "설비(EQP) 목록"을 가져오는 API
export const fetchEquipments = async (lineId, sdwtId) => {
  const params = new URLSearchParams({ lineId });
  if (sdwtId) params.append("sdwtId", sdwtId);
  const response = await fetch(`${API_BASE_URL}/equipments?${params}`);
  if (!response.ok) throw new Error("Failed to fetch equipments");
  return response.json();
};

// 특정 설비의 "가동 상태(RUN)" 데이터를 가져오는 API
export const fetchEQPStatus = async (eqpId) => {
  const response = await fetch(`${API_BASE_URL}/run-status?eqpId=${eqpId}`);
  if (!response.ok) throw new Error("Failed to fetch run status");
  return response.json();
};

// 특정 설비의 "Tip 상태(TIP)" 데이터를 가져오는 API
export const fetchTIPLog = async (eqpId) => {
  const response = await fetch(`${API_BASE_URL}/step-status?eqpId=${eqpId}`);
  if (!response.ok) throw new Error("Failed to fetch step status");
  return response.json();
};

// 특정 설비의 "RACB 로그(변경점)" 데이터를 가져오는 API
export const fetchRACBLog = async (eqpId) => {
  const response = await fetch(`${API_BASE_URL}/event-log?eqpId=${eqpId}`);
  if (!response.ok) throw new Error("Failed to fetch event log");
  return response.json();
};

// 특정 설비의 "CTTTM 로그" 데이터를 가져오는 API
export const fetchCTTTMLog = async (eqpId) => {
  const response = await fetch(`${API_BASE_URL}/ctttm-log?eqpId=${eqpId}`);
  if (!response.ok) throw new Error("Failed to fetch CTTTM log");
  return response.json();
};

// SDWT 목록 API
export const fetchSDWT = async (lineId) => {
  const response = await fetch(`${API_BASE_URL}/sdwt?lineId=${lineId}`);
  if (!response.ok) throw new Error("Failed to fetch SDWT");
  return response.json();
};


----- C:\Users\pjw75\Desktop\react-prc\src\components\common\LoadingSpinner.jsx -----

import React from "react";

// 로딩 중일 때 보여주는 스피너 컴포넌트
const LoadingSpinner = () => (
  <div className="flex justify-center items-center">
    <div className="animate-spin rounded-full h-5 w-5 border-4 border-blue-500 border-t-transparent" />
  </div>
);

export default LoadingSpinner;


----- C:\Users\pjw75\Desktop\react-prc\src\components\common\Navbar.jsx -----

import React, { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import {
  Dialog,
  DialogPanel,
  Disclosure,
  DisclosureButton,
  DisclosurePanel,
  Popover,
  PopoverButton,
  PopoverGroup,
  PopoverPanel,
} from "@headlessui/react";
import {
  ArrowPathIcon,
  Bars3Icon,
  ChartPieIcon,
  CursorArrowRaysIcon,
  FingerPrintIcon,
  SquaresPlusIcon,
  XMarkIcon,
  SunIcon,
  MoonIcon,
} from "@heroicons/react/24/outline";
import {
  ChevronDownIcon,
  PhoneIcon,
  PlayCircleIcon,
} from "@heroicons/react/20/solid";

// "Product" 드롭다운에 사용될 예시 데이터
const products = [
  {
    name: "Analytics",
    description: "트래픽 분석",
    href: "#",
    icon: ChartPieIcon,
  },
  {
    name: "Engagement",
    description: "고객 소통",
    href: "#",
    icon: CursorArrowRaysIcon,
  },
  {
    name: "Security",
    description: "데이터 보안",
    href: "#",
    icon: FingerPrintIcon,
  },
  {
    name: "Integrations",
    description: "외부 연동",
    href: "#",
    icon: SquaresPlusIcon,
  },
  {
    name: "Automations",
    description: "자동화",
    href: "#",
    icon: ArrowPathIcon,
  },
];
const callsToAction = [
  { name: "Watch demo", href: "#", icon: PlayCircleIcon },
  { name: "Contact sales", href: "#", icon: PhoneIcon },
];

export default function Navbar() {
  // 모바일 메뉴와 다크모드 상태를 관리
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [darkMode, setDarkMode] = useState(false);

  // 컴포넌트가 처음 마운트될 때, localStorage나 OS 기본 테마를 기준으로 다크모드 설정을 결정
  useEffect(() => {
    const isDark =
      localStorage.theme === "dark" ||
      (!("theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches);
    setDarkMode(isDark);
    if (isDark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, []);

  // 다크모드 토글 (버튼 클릭 시 실행)
  const toggleDarkMode = () => {
    const newDarkMode = !darkMode;
    setDarkMode(newDarkMode);
    if (newDarkMode) {
      localStorage.theme = "dark";
      document.documentElement.classList.add("dark");
    } else {
      localStorage.theme = "light";
      document.documentElement.classList.remove("dark");
    }
  };

  return (
    // 상단 고정 네비게이션 바
    <header className="bg-gray-100 dark:bg-gray-800 shadow-md sticky top-0 z-50  h-20">
      <nav
        aria-label="Global"
        className="mx-auto flex max-w-7xl items-center justify-between p-5 lg:px-8"
      >
        {/* 로고: 메인 페이지로 이동 */}
        <div className="flex lg:flex-1">
          <Link to="/" className="-m-1.5 p-1.5">
            <span className="sr-only">Your Company</span>
            <img
              alt="Company Logo"
              src="https://tailwindcss.com/plus-assets/img/logos/158x48/transistor-logo-gray-900.svg"
              className="h-8 w-auto"
            />
          </Link>
        </div>
        {/* 모바일 메뉴 버튼 (작은 화면에서만 보임) */}
        <div className="flex lg:hidden">
          <button
            type="button"
            onClick={() => setMobileMenuOpen(true)}
            className="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700 dark:text-gray-300"
          >
            <span className="sr-only">Open main menu</span>
            <Bars3Icon aria-hidden="true" className="size-6" />
          </button>
        </div>
        {/* 데스크탑 메뉴: Product, Timeline 등 네비게이션 */}
        <PopoverGroup className="hidden lg:flex lg:gap-x-12">
          <Popover className="relative">
            <PopoverButton className="flex items-center gap-x-1 text-sm/6 font-semibold text-gray-900 dark:text-gray-100 focus:outline-none">
              Product
              <ChevronDownIcon
                aria-hidden="true"
                className="size-5 flex-none text-gray-400 dark:text-gray-500"
              />
            </PopoverButton>
            {/* Product 드롭다운 패널 */}
            <PopoverPanel
              transition
              className="absolute top-full -left-8 z-20 mt-3 w-screen max-w-md overflow-hidden rounded-3xl bg-white dark:bg-gray-800 shadow-lg ring-1 ring-gray-900/5 dark:ring-white/10 transition"
            >
              <div className="p-4">
                {products.map((item) => (
                  <div
                    key={item.name}
                    className="group relative flex items-center gap-x-6 rounded-lg p-4 text-sm/6 hover:bg-gray-50 dark:hover:bg-gray-700"
                  >
                    <div className="flex size-11 flex-none items-center justify-center rounded-lg bg-gray-50 dark:bg-gray-700 group-hover:bg-white dark:group-hover:bg-gray-600">
                      <item.icon
                        aria-hidden="true"
                        className="size-6 text-gray-600 dark:text-gray-400 group-hover:text-indigo-600 dark:group-hover:text-indigo-400"
                      />
                    </div>
                    <div className="flex-auto">
                      <a
                        href={item.href}
                        className="block font-semibold text-gray-900 dark:text-gray-100"
                      >
                        {item.name}
                        <span className="absolute inset-0" />
                      </a>
                      <p className="mt-1 text-gray-600 dark:text-gray-400">
                        {item.description}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
              {/* 하단 액션 버튼 */}
              <div className="grid grid-cols-2 divide-x divide-gray-900/5 dark:divide-white/10 bg-gray-50 dark:bg-gray-700/50">
                {callsToAction.map((item) => (
                  <a
                    key={item.name}
                    href={item.href}
                    className="flex items-center justify-center gap-x-2.5 p-3 text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-600"
                  >
                    <item.icon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500"
                    />
                    {item.name}
                  </a>
                ))}
              </div>
            </PopoverPanel>
          </Popover>
          {/* 타임라인 페이지로 이동하는 메뉴 */}
          <Link
            to="/timeline"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Timeline
          </Link>
          <a
            href="#"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Marketplace
          </a>
          <a
            href="#"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Company
          </a>
        </PopoverGroup>
        {/* 데스크탑: 다크모드 토글 + 로그인 */}
        <div className="hidden lg:flex lg:flex-1 lg:items-center lg:justify-end lg:gap-x-6">
          <button
            onClick={toggleDarkMode}
            className="p-2 rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none"
            aria-label="Toggle dark mode"
          >
            {darkMode ? (
              <SunIcon className="size-6" />
            ) : (
              <MoonIcon className="size-6" />
            )}
          </button>
          <a
            href="#"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Log in <span aria-hidden="true">&rarr;</span>
          </a>
        </div>
      </nav>
      {/* 모바일 메뉴 다이얼로그: 작은 화면에서만 열림 */}
      <Dialog
        open={mobileMenuOpen}
        onClose={setMobileMenuOpen}
        className="lg:hidden"
      >
        <div className="fixed inset-0 z-20" />
        <DialogPanel className="fixed inset-y-0 right-0 z-30 w-full overflow-y-auto bg-white dark:bg-gray-800 px-6 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10 dark:sm:ring-white/10">
          <div className="flex items-center justify-between">
            <Link
              to="/"
              className="-m-1.5 p-1.5"
              onClick={() => setMobileMenuOpen(false)}
            >
              <span className="sr-only">Your Company</span>
              <img
                alt="Company Logo"
                src="https://tailwindcss.com/img/logos/mark.svg?color=indigo&shade=600"
                className="h-8 w-auto"
              />
            </Link>
            <button
              type="button"
              onClick={() => setMobileMenuOpen(false)}
              className="-m-2.5 rounded-md p-2.5 text-gray-700 dark:text-gray-300"
            >
              <span className="sr-only">Close menu</span>
              <XMarkIcon aria-hidden="true" className="size-6" />
            </button>
          </div>
          <div className="mt-6 flow-root">
            <div className="-my-6 divide-y divide-gray-500/10 dark:divide-gray-700">
              <div className="space-y-2 py-6">
                {/* Product 드롭다운 (모바일) */}
                <Disclosure as="div" className="-mx-3">
                  <DisclosureButton className="group flex w-full items-center justify-between rounded-lg py-2 pr-3.5 pl-3 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700">
                    Product
                    <ChevronDownIcon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500 group-data-open:rotate-180"
                    />
                  </DisclosureButton>
                  <DisclosurePanel className="mt-2 space-y-2">
                    {[...products, ...callsToAction].map((item) => (
                      <DisclosureButton
                        key={item.name}
                        as="a"
                        href={item.href}
                        onClick={() => setMobileMenuOpen(false)}
                        className="block rounded-lg py-2 pr-3 pl-6 text-sm/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                      >
                        {item.name}
                      </DisclosureButton>
                    ))}
                  </DisclosurePanel>
                </Disclosure>
                {/* 주요 메뉴들 */}
                <Link
                  to="/timeline"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Timeline
                </Link>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Marketplace
                </a>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Company
                </a>
              </div>
              <div className="py-6">
                {/* 다크모드 토글 (모바일) */}
                <button
                  onClick={() => {
                    toggleDarkMode();
                    setMobileMenuOpen(false);
                  }}
                  className="-mx-3 flex items-center gap-x-2 w-full rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                  aria-label="Toggle dark mode"
                >
                  {darkMode ? (
                    <SunIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  ) : (
                    <MoonIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  )}
                  {darkMode ? "라이트 모드" : "다크 모드"}
                </button>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Log in
                </a>
              </div>
            </div>
          </div>
        </DialogPanel>
      </Dialog>
    </header>
  );
}


----- C:\Users\pjw75\Desktop\react-prc\src\components\selectors\EqpSelector.jsx -----

import React from "react";
import { useEquipments } from "../../hooks/useLineQueries";
import LoadingSpinner from "../common/LoadingSpinner";

/**
 * 선택된 라인(lineId)에 연결된 설비(EQP) 목록을 드롭다운으로 보여주는 컴포넌트입니다.
 * - lineId가 없으면 드롭다운이 비활성화됩니다.
 * - 장비 선택 시 setEqpId를 통해 상위 컴포넌트로 선택값이 전달됩니다.
 */
const EqpSelector = ({ lineId, sdwtId, eqpId, setEqpId }) => {
  const { data: eqps = [], isLoading } = useEquipments(
    lineId,
    sdwtId,
    !!lineId && !!sdwtId
  );

  // 라인이 선택되지 않은 경우: 비활성화된 드롭다운만 표시
  if (!lineId)
    return (
      <select
        disabled
        className={
          "w-full appearance-none block px-3 py-1.5 border border-slate-300 dark:border-slate-600 " +
          "rounded-lg shadow-sm placeholder-slate-400 dark:placeholder-slate-500 " +
          "focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 " +
          "text-sm text-slate-500 dark:text-slate-400 " +
          "bg-slate-100 dark:bg-slate-800 cursor-not-allowed " +
          "transition duration-150 ease-in-out"
        }
      >
        <option value="">EQP 선택…</option>
      </select>
    );

  // 로딩 중일 때: 스피너 표시
  if (isLoading) return <LoadingSpinner />;

  // 정상 데이터 표시
  return (
    <div className="relative">
      <select
        value={eqpId ?? ""}
        onChange={(e) => setEqpId(e.target.value)}
        disabled={!lineId || eqps.length === 0}
        className={
          "w-full appearance-none block px-3 py-1.5 border border-slate-300 dark:border-slate-600 " +
          "rounded-lg shadow-sm placeholder-slate-400 dark:placeholder-slate-500 " +
          "focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 " +
          "text-sm text-slate-900 dark:text-slate-100 " +
          "bg-white dark:bg-slate-700 " +
          "transition duration-150 ease-in-out " +
          `${
            !lineId || eqps.length === 0
              ? "bg-slate-100 dark:bg-slate-800 text-slate-500 dark:text-slate-400 cursor-not-allowed"
              : ""
          }`
        }
      >
        {/* 기본 옵션 */}
        <option value="" className="text-slate-500 dark:text-slate-400">
          EQP 선택…
        </option>
        {/* 해당 라인에 EQP가 없을 때 안내 메시지 */}
        {eqps.length === 0 && lineId && (
          <option
            value=""
            disabled
            className="text-slate-500 dark:text-slate-400"
          >
            해당 라인에 EQP가 없습니다.
          </option>
        )}
        {/* EQP 목록을 옵션으로 렌더링 */}
        {eqps.map((e) => (
          <option
            key={e.id}
            value={e.id}
            className="dark:bg-slate-700 dark:text-slate-100 text-slate-500 bg-white"
          >
            {e.name}
          </option>
        ))}
      </select>
      {/* (추후 커스텀 드롭다운 화살표 아이콘을 추가할 수 있습니다.) */}
    </div>
  );
};

export default EqpSelector;


----- C:\Users\pjw75\Desktop\react-prc\src\components\selectors\LineSelector.jsx -----

import React from "react";
import { useLines } from "../../hooks/useLineQueries";
import LoadingSpinner from "../common/LoadingSpinner";

/**
 * 라인(line) 목록을 드롭다운으로 표시하고,
 * 선택된 라인 ID를 setLineId로 상위에 전달합니다.
 */
const LineSelector = ({ lineId, setLineId }) => {
  // 라인 목록 데이터와 로딩상태 가져오기
  const { data: lines = [], isLoading } = useLines();

  // 로딩 중엔 스피너 표시
  if (isLoading) return <LoadingSpinner />;

  // 드롭다운 표시
  return (
    <div className="relative">
      <select
        value={lineId ?? ""}
        onChange={(e) => setLineId(e.target.value)}
        className={
          "w-full appearance-none block px-3 py-1.5 border border-slate-300 dark:border-slate-600 " +
          "rounded-lg shadow-sm placeholder-slate-400 dark:placeholder-slate-500 " +
          "focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 " +
          "text-sm text-slate-900 dark:text-slate-100 " +
          "bg-white dark:bg-slate-700 " +
          "transition duration-150 ease-in-out"
        }
      >
        {/* 기본 안내 옵션 */}
        <option value="" className="text-slate-500 dark:text-slate-400">
          라인 선택…
        </option>
        {/* 라인 목록을 옵션으로 표시 */}
        {lines.map((l) => (
          <option
            key={l.id}
            value={l.id}
            className="dark:bg-slate-700 dark:text-slate-100 text-slate-500 bg-white"
          >
            {l.name}
          </option>
        ))}
      </select>
    </div>
  );
};

export default LineSelector;


----- C:\Users\pjw75\Desktop\react-prc\src\components\selectors\SDWTSelector.jsx -----

// src/components/selectors/SDWTSelector.jsx
import React from "react";
import { useSDWTQueries } from "../../hooks/useSDWTQueries";
import LoadingSpinner from "../common/LoadingSpinner";

const SDWTSelector = ({ lineId, sdwtId, setSdwtId }) => {
  const { data: sdwts = [], isLoading } = useSDWTQueries(lineId);

  if (!lineId)
    return (
      <select
        disabled
        className={
          "w-full appearance-none block px-3 py-1.5 border border-slate-300 dark:border-slate-600 " +
          "rounded-lg shadow-sm placeholder-slate-400 dark:placeholder-slate-500 " +
          "focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 " +
          "text-sm text-slate-500 dark:text-slate-400 " +
          "bg-slate-100 dark:bg-slate-800 cursor-not-allowed " +
          "transition duration-150 ease-in-out"
        }
      >
        <option>SDWT 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <div className="relative">
      <select
        value={sdwtId ?? ""}
        onChange={(e) => setSdwtId(e.target.value)}
        className={
          "w-full appearance-none block px-3 py-1.5 border border-slate-300 dark:border-slate-600 " +
          "rounded-lg shadow-sm placeholder-slate-400 dark:placeholder-slate-500 " +
          "focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 " +
          "text-sm text-slate-900 dark:text-slate-100 " +
          "bg-white dark:bg-slate-700 " +
          "transition duration-150 ease-in-out"
        }
      >
        <option value="">SDWT 선택…</option>
        {sdwts.map((s) => (
          <option key={s.id} value={s.id}>
            {s.name}
          </option>
        ))}
      </select>
    </div>
  );
};

export default SDWTSelector;


----- C:\Users\pjw75\Desktop\react-prc\src\components\tables\CombinedDataTable.jsx -----

import { useRef, useEffect } from "react";
import { useSelection } from "../../context/SelectionContext";

/**
 * 여러 데이터 타입(RUN/STEP/EVENT 등)을 시간순으로 통합해서 보여주는 테이블입니다.
 * - data: [{displayTimestamp, type, info1, info2, info3, ...}] 형태의 배열
 */
const CombinedDataTable = ({ data }) => {
  const { selectedRow, setSelectedRow } = useSelection();
  const rowRefs = useRef({});

  useEffect(() => {
    if (selectedRow && rowRefs.current[selectedRow]) {
      rowRefs.current[selectedRow].scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    } else if (selectedRow) {
      // 렌더 타이밍 문제로 100ms 후 재시도
      setTimeout(() => {
        if (rowRefs.current[selectedRow]) {
          rowRefs.current[selectedRow].scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }, 100);
    }
  }, [selectedRow, data]);

  // 데이터 없으면 안내 메시지
  if (!data || data.length === 0) {
    return (
      <p className="text-sm text-gray-500 dark:text-gray-400">
        표시할 데이터가 없습니다. 필터를 확인해주세요.
      </p>
    );
  }

  // 테이블 컬럼 정의
  const columns = [
    { header: "시간", accessor: "displayTimestamp" },
    { header: "타입", accessor: "type" },
    { header: "정보 1", accessor: "info1" },
    { header: "정보 2", accessor: "info2" },
  ];

  return (
    <div className="overflow-x-auto shadow-md sm:rounded-lg">
      <h3 className="text-lg font-semibold p-4 bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-white rounded-t-lg">
        통합 데이터 로그
      </h3>
      <div className="overflow-y-auto max-h-135 table-scroll">
        <table className="w-full text-sm text-center text-gray-800 dark:text-gray-200">
          <thead className="sticky top-0 bg-gray-50 text-gray-900 dark:bg-gray-600 dark:text-gray-100">
            <tr>
              {columns.map((col) => (
                <th key={col.accessor} className="px-6 py-3 font-semibold">
                  {col.header}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {data.map((item) => {
              const rowId = item.id;
              const isSelected = String(rowId) === String(selectedRow);

              console.log(
                "rowId",
                rowId,
                "| selectedRow",
                selectedRow,
                "| match:",
                isSelected
              );

              return (
                <tr
                  key={rowId}
                  ref={(el) => (rowRefs.current[rowId] = el)}
                  className={`transition-colors duration-300 ${
                    isSelected
                      ? "bg-yellow-100 dark:bg-yellow-800"
                      : "bg-white dark:bg-gray-800"
                  }`}
                  onClick={() => setSelectedRow(rowId)}
                >
                  {columns.map((col) => (
                    <td key={col.accessor} className="px-6 py-4">
                      {item[col.accessor] || "-"}
                    </td>
                  ))}
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default CombinedDataTable;


----- C:\Users\pjw75\Desktop\react-prc\src\components\timeline\hooks\useTimeline.js -----

import { useRef } from "react";
import { useTimelineRenderer } from "./useTimelineRenderer";

/**
 * 타임라인을 만들기 위한 커스텀 훅입니다.
 * - containerRef: 타임라인이 표시될 DOM 참조(React의 useRef로 만든 div 등)
 * - groupKey: 데이터 그룹 식별자 (예: "EQP_STATUS", "TIP_STATUS" 등)
 * - data: 타임라인에 표시할 데이터
 * - range: 타임라인의 시간 범위({min, max})
 *
 * 실제 타임라인 생성/업데이트 로직은 useTimelineRenderer 훅에 위임합니다.
 */
export const useTimeline = (containerRef, groupKey, data, range) => {
  // useTimelineRenderer 내부에서 타임라인 인스턴스를 만들어서 관리합니다.
  const tl = useTimelineRenderer(containerRef, groupKey, data, range);
  return tl;
};


----- C:\Users\pjw75\Desktop\react-prc\src\components\timeline\hooks\useTimelineRenderer.js -----

import { useContext, useEffect, useRef, useMemo } from "react";
import { Timeline, DataSet } from "vis-timeline/standalone";
import { TimelineContext } from "../../../context/TimelineProvider";
import { processData } from "../../../utils/timelineUtils";
import { groupConfig } from "../../../utils/timelineMeta";
import moment from "moment";
import "moment/locale/ko";
moment.locale("ko");
/**
 * 실제 vis-timeline 인스턴스를 생성/업데이트/해제하는 역할을 하는 커스텀 훅입니다.
 * - 타임라인 인스턴스의 X축 동기화, 옵션 변화 반영 등을 관리합니다.
 */
export const useTimelineRenderer = (containerRef, groupKey, data, range) => {
  const tlRef = useRef(null); // 타임라인 인스턴스 참조
  const { poolRef, register, unregister } = useContext(TimelineContext);

  // 그룹별 옵션 (useMemo로 캐싱)
  const groupOptions = useMemo(() => {
    return groupConfig[groupKey]?.options ?? {};
  }, [groupKey]);

  // 1. 타임라인 인스턴스 생성 및 파괴
  useEffect(() => {
    if (!containerRef.current) return;

    // 타임라인 옵션 설정 (X축 min/max 포함)
    const initialMergedOptions = {
      stack: false,
      zoomMin: 1000 * 60 * 30,
      zoomMax: 1000 * 60 * 60 * 24 * 30,
      ...groupOptions,
      min: range.min,
      max: range.max,
      locale: "ko", // 브라우저가 지원해야 제대로 나옴
      format: {
        minorLabels: {
          millisecond: "SSS",
          second: "s초",
          minute: "HH:mm",
          hour: "HH:mm",
          weekday: "MM/DD(ddd)", // 예: 05/21(수)
          day: "DD(ddd)",
          week: "w주",
          month: "MM월",
          year: "YY년",
        },
        majorLabels: {
          millisecond: "HH:mm:ss",
          second: "DD일 HH:mm",
          minute: "MM/DD(ddd)",
          hour: "MM/DD(ddd)",
          weekday: "YYYY/MM",
          day: "YYYY/MM",
          week: "YYYY/MM",
          month: "YYYY년",
          year: "",
        },
      },
    };

    // 데이터 가공 및 타임라인 생성
    const items = new DataSet(processData(groupKey, data, range.max));
    tlRef.current = new Timeline(
      containerRef.current,
      items,
      initialMergedOptions
    );
    tlRef.current.setWindow(range.min, range.max); // 최초 보이는 구간

    // 타임라인 pool에 등록 (동기화 위해)
    register(tlRef.current);

    // X축 동기화: 다른 타임라인도 같이 움직이게 함
    const currentTl = tlRef.current;
    const handleRangeChange = ({ start, end }) => {
      poolRef.current.forEach((tl) => {
        if (tl !== currentTl) {
          tl.setWindow(start, end, { animation: false });
        }
      });
    };
    currentTl.on("rangechange", handleRangeChange);

    // 언마운트시: pool 해제 + 이벤트 해제 + 파괴
    return () => {
      unregister(currentTl);
      currentTl.off("rangechange", handleRangeChange);
      currentTl.destroy();
      tlRef.current = null;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [containerRef, groupKey, poolRef, register, unregister]);

  // 2. 데이터가 바뀔 때마다 타임라인 데이터만 갱신
  useEffect(() => {
    if (tlRef.current) {
      tlRef.current.setItems(
        new DataSet(processData(groupKey, data, range.max))
      );
    }
  }, [data, groupKey, range.max]);

  // 3. range(구간), 옵션 등이 바뀔 때마다 타임라인 옵션 및 윈도우 업데이트
  useEffect(() => {
    if (tlRef.current) {
      const updatedMergedOptions = {
        stack: false,
        zoomMin: 1000 * 60 * 30,
        zoomMax: 1000 * 60 * 60 * 24 * 30,
        ...groupOptions,
        min: range.min,
        max: range.max,
      };
      tlRef.current.setOptions(updatedMergedOptions);
      tlRef.current.setWindow(range.min, range.max);
    }
  }, [range, groupOptions]);

  return tlRef;
};


----- C:\Users\pjw75\Desktop\react-prc\src\components\timeline\NonStackedTimeline.jsx -----

// src/components/timeline/NonStackedTimeline.jsx
import React, { useEffect, useRef, useContext } from "react";
import { Timeline, DataSet } from "vis-timeline/standalone";
import { processData } from "../../utils/timelineUtils";
import { TimelineContext } from "../../context/TimelineProvider";
import { useSelection } from "../../context/SelectionContext";

const NonStackedTimeline = ({ dataMap, range }) => {
  const containerRef = useRef(null);
  const { register, unregister, poolRef } = useContext(TimelineContext);
  const { selectedRow, setSelectedRow } = useSelection();

  const groups = new DataSet([
    {
      id: "EQP_LOG",
      content: "EQP 상태",
      style: "width: 120px;",
      className: "custom-group-label",
    },
    {
      id: "TIP_LOG",
      content: "TIP 상태",
      style: "width: 120px;",
      className: "custom-group-label",
    },
  ]);

  useEffect(() => {
    const items = new DataSet(
      groups
        .get()
        .flatMap((g) => processData(g.id, dataMap[g.id] || [], range.max))
    );

    const timeline = new Timeline(containerRef.current, items, groups, {
      stack: false,
      min: range.min,
      max: range.max,
      margin: { item: 0, axis: 0 },
      verticalScroll: false,
      groupOrder: (a, b) =>
        groups.get().findIndex((g) => g.id === a.id) -
        groups.get().findIndex((g) => g.id === b.id),
    });

    timeline.setWindow(range.min, range.max);
    register(timeline);

    const sync = ({ start, end }) => {
      poolRef.current.forEach((tl) => {
        if (tl !== timeline) tl.setWindow(start, end, { animation: false });
      });
    };
    timeline.on("rangechange", sync);

    timeline.on("select", (props) => {
      if (props.items?.length) {
        const selectedItem = timeline.itemsData.get(props.items[0]);
        const matchedId = selectedItem?.id;
        if (matchedId) {
          setSelectedRow(matchedId); // 정확한 ID 저장
        }
      } else {
        setSelectedRow(null);
      }
    });

    return () => {
      unregister(timeline);
      timeline.off("rangechange", sync);
      timeline.destroy();
    };
  }, [dataMap, range]);

  useEffect(() => {
    if (!containerRef.current) return;

    // 1) pool 에서 내 타임라인을 찾는다
    const tl = poolRef.current.find(
      (t) => t.dom?.container === containerRef.current
    );
    if (!tl) return;

    // 2) 현재 선택된 ID가 이 타임라인 안에 있는지 확인
    const hasItem =
      tl.itemsData?.get instanceof Function && tl.itemsData.get(selectedRow);

    if (selectedRow && hasItem) {
      tl.setSelection([selectedRow]);
      //tl.focus(selectedRow, { animation: { duration: 300 }, zoom: false });
    } else {
      tl.setSelection([]); // 없으면 선택 해제
    }
  }, [selectedRow, poolRef]);

  return (
    <div className="timeline-container">
      <h3 className="text-sm font-semibold mb-1 text-slate-600 dark:text-slate-300">
        ⛓ EQP + TIP 로그
      </h3>
      <div ref={containerRef} className="timeline" />
    </div>
  );
};

export default NonStackedTimeline;


----- C:\Users\pjw75\Desktop\react-prc\src\components\timeline\StackedTimeline.jsx -----

// src/components/timeline/StackedTimeline.jsx
import React, { useEffect, useRef, useContext } from "react";
import { Timeline, DataSet } from "vis-timeline/standalone";
import { processData } from "../../utils/timelineUtils";
import { TimelineContext } from "../../context/TimelineProvider";
import { useSelection } from "../../context/SelectionContext";

const StackedTimeline = ({ dataMap, range }) => {
  const containerRef = useRef(null);
  const { register, unregister, poolRef } = useContext(TimelineContext);
  const { selectedRow, setSelectedRow } = useSelection();

  // 그룹 정의 (고정 너비 설정)
  const groups = new DataSet([
    {
      id: "CTTTM_LOG",
      content: "CTTTM 이벤트",
      height: 150,
      className: "custom-group-label",
    },
    {
      id: "RACB_LOG",
      content: "RACB 이벤트",
      height: 150,
      className: "custom-group-label",
    },
  ]);

  useEffect(() => {
    // items 구성 시 배열로 변환하여 flatMap 사용
    const items = new DataSet(
      groups
        .get()
        .flatMap((g) => processData(g.id, dataMap[g.id] || [], range.max))
    );

    const timeline = new Timeline(containerRef.current, items, groups, {
      height: "550px",
      stack: true,
      min: range.min,
      max: range.max,
      locale: "ko",
      verticalScroll: false,
      margin: { item: 0, axis: 0 },

      groupHeightMode: "fixed",

      groupOrder: (a, b) =>
        groups.get().findIndex((g) => g.id === a.id) -
        groups.get().findIndex((g) => g.id === b.id),
    });

    timeline.setWindow(range.min, range.max);
    register(timeline);

    const sync = ({ start, end }) => {
      poolRef.current.forEach((tl) => {
        if (tl !== timeline) {
          tl.setWindow(start, end, { animation: false });
        }
      });
    };
    timeline.on("rangechange", sync);

    // ✅ 선택 이벤트 연결
    timeline.on("select", (props) => {
      // 방어코드 추가
      const selectedId = props.items?.[0];
      if (selectedId && typeof selectedId === "string") {
        setSelectedRow(selectedId);
      } else {
        setSelectedRow(null);
      }
    });

    return () => {
      unregister(timeline);
      timeline.off("rangechange", sync);
      timeline.destroy();
    };
  }, [dataMap, range]);

  /* 🔄 2-way sync: 컨텍스트가 변하면 타임라인도 선택·포커스 */
  useEffect(() => {
    if (!containerRef.current) return;

    // 1) pool 에서 내 타임라인을 찾는다
    const tl = poolRef.current.find(
      (t) => t.dom?.container === containerRef.current
    );
    if (!tl) return;

    // 2) 현재 선택된 ID가 이 타임라인 안에 있는지 확인
    // 2-1) selectedRow가 없거나, string 타입이 아닌 경우 리턴
    if (!selectedRow || typeof selectedRow !== "string") {
      tl.setSelection([]);
      return;
    }

    // 2-2) itemsData에 실제로 존재하는 아이템인지 체크
    const hasItem =
      tl.itemsData?.get instanceof Function && tl.itemsData.get(selectedRow);

    if (hasItem) {
      tl.setSelection([selectedRow]);
      try {
        tl.focus(selectedRow, { animation: { duration: 300 } });
      } catch (e) {
        // 에러 발생 시(예: 아이템이 사라졌거나 애니메이션 불가 등) 안전하게 무시
        console.warn("Timeline focus error:", e);
      }
    } else {
      tl.setSelection([]);
      // 🚨🚨🚨 없는 selectedRow는 자동 초기화 (여기선 내부적으로만)
      if (selectedRow) setSelectedRow(null);
    }
  }, [selectedRow, poolRef, setSelectedRow]);

  return (
    <div className="timeline-container">
      <h3 className="text-sm font-semibold mb-1 text-slate-600 dark:text-slate-300">
        📍 CTTTM + RACB 로그
      </h3>
      <div
        ref={containerRef}
        className="timeline"
        style={{
          height: "550px", // ✅ 고정 높이
          overflow: "hidden", // ✅ 스크롤 방지
        }}
      />
    </div>
  );
};

export default StackedTimeline;


----- C:\Users\pjw75\Desktop\react-prc\src\components\timeline\TimelineBoard.jsx -----

import React from "react";
import { useEqpStatusLog } from "../../hooks/useEqpStatusLog";
import { useTipLog } from "../../hooks/useTIPLog";
import { useRacbLog } from "../../hooks/useRacbLog";
import { useCtttmLog } from "../../hooks/useCTTTMLog";
import LoadingSpinner from "../common/LoadingSpinner";
import NonStackedTimeline from "./NonStackedTimeline";
import StackedTimeline from "./StackedTimeline";
import { calcRange, addBuffer } from "../../utils/timelineUtils";

const TimelineBoard = ({ eqpId }) => {
  const { data: eqp_log = [], isLoading: l1 } = useEqpStatusLog(eqpId);
  const { data: tip_log = [], isLoading: l2 } = useTipLog(eqpId);
  const { data: racb_log = [], isLoading: l3 } = useRacbLog(eqpId);
  const { data: ctttm_log = [], isLoading: l4 } = useCtttmLog(eqpId);

  if (!eqpId) return null;
  if (l1 || l2 || l3 || l4) return <LoadingSpinner />;

  const range = calcRange(eqp_log, tip_log, racb_log, ctttm_log);
  const fullRange = addBuffer(range.min.getTime(), range.max.getTime());

  return (
    <div className="w-full space-y-4">
      <NonStackedTimeline
        dataMap={{ EQP_LOG: eqp_log, TIP_LOG: tip_log }}
        range={fullRange}
      />
      <StackedTimeline
        dataMap={{ CTTTM_LOG: ctttm_log, RACB_LOG: racb_log }}
        range={fullRange}
      />
    </div>
  );
};

export default TimelineBoard;


----- C:\Users\pjw75\Desktop\react-prc\src\components\timeline\UnifiedTimeline.jsx -----

// src/components/timeline/UnifiedTimeline.jsx
import React, { useEffect, useRef, useContext } from "react";
import { Timeline, DataSet } from "vis-timeline/standalone";
import { processData } from "../../utils/timelineUtils";
import { TimelineContext } from "../../context/TimelineProvider";
import { useSelection } from "../../context/SelectionContext";

const UnifiedTimeline = ({ dataMap, range }) => {
  const containerRef = useRef(null);
  const { poolRef, register, unregister } = useContext(TimelineContext);
  const { selectedRow, setSelectedRow } = useSelection();

  // 그룹 순서 정의
  const groupOrderList = ["EQP_LOG", "TIP_LOG", "CTTTM_LOG", "RACB_LOG"];

  // 그룹별 stack 여부 정의
  const groupStackMap = {
    EQP_LOG: false,
    TIP_LOG: false,
    CTTTM_LOG: true,
    RACB_LOG: true,
  };

  useEffect(() => {
    const groups = new DataSet(
      groupOrderList.map((key) => ({
        id: key,
        content: key,
      }))
    );

    const items = new DataSet(
      groupOrderList.flatMap((key) =>
        processData(key, dataMap[key] || [], range.max)
      )
    );

    const timeline = new Timeline(containerRef.current, items, groups, {
      zoomMin: 1000 * 60 * 30,
      zoomMax: 1000 * 60 * 60 * 24 * 30,
      min: range.min,
      max: range.max,
      stack: true, // 기본 stack은 true지만,
      groupStack: (groupId) => groupStackMap[groupId] ?? false,
      groupOrder: (a, b) =>
        groupOrderList.indexOf(a.id) - groupOrderList.indexOf(b.id),
      verticalScroll: false,
      margin: {
        item: 0,
        axis: 0,
      },
      format: {
        minorLabels: {
          millisecond: "SSS",
          second: "s초",
          minute: "HH:mm",
          hour: "HH:mm",
          weekday: "MM/DD(ddd)",
          day: "DD(ddd)",
          week: "w주",
          month: "MM월",
          year: "YY년",
        },
        majorLabels: {
          millisecond: "HH:mm:ss",
          second: "DD일 HH:mm",
          minute: "MM/DD(ddd)",
          hour: "MM/DD(ddd)",
          weekday: "YYYY/MM",
          day: "YYYY/MM",
          week: "YYYY/MM",
          month: "YYYY년",
          year: "",
        },
      },
    });

    // 타임라인 select 이벤트 처리
    timeline.on("select", function (props) {
      if (props.items.length > 0) {
        const selectedId = props.items[0]; // ex: "EQP_LOG-3"
        setSelectedRow(selectedId); // 아이디 또는 timestamp 기반으로 설정
      }
    });

    timeline.setWindow(range.min, range.max);
    register(timeline);

    const handleRangeChange = ({ start, end }) => {
      poolRef.current.forEach((tl) => {
        if (tl !== timeline) {
          tl.setWindow(start, end, { animation: false });
        }
      });
    };

    timeline.on("rangechange", handleRangeChange);

    /* 🔄 2-way sync: 컨텍스트가 변하면 타임라인도 선택·포커스 */
    useEffect(() => {
      if (!containerRef.current) return;
      const tl = poolRef.current.find(
        (t) => t.dom?.container === containerRef.current
      );
      if (!tl) return;

      if (selectedRow) {
        tl.setSelection([selectedRow]);
        tl.focus(selectedRow, { animation: { duration: 300 } });
      } else {
        tl.setSelection([]);
      }
    }, [selectedRow, poolRef]);

    return () => {
      timeline.off("rangechange", handleRangeChange);
      unregister(timeline);
      timeline.destroy();
    };
  }, [dataMap, range, poolRef, register, unregister, setSelectedRow]);

  return (
    <div className="timeline-container unified-timeline">
      <div ref={containerRef} className="timeline" />
    </div>
  );
};

export default UnifiedTimeline;


----- C:\Users\pjw75\Desktop\react-prc\src\context\SelectionContext.jsx -----

import React, { createContext, useState, useContext } from "react";

// "선택된 테이블 행" 상태를 전역에서 공유할 수 있게 해주는 Context입니다.
const SelectionContext = createContext();

// 이 훅을 사용하면 하위 컴포넌트에서 쉽게 선택 상태에 접근/설정할 수 있습니다.
export const useSelection = () => useContext(SelectionContext);

/**
 * SelectionProvider로 감싸면, 하위 컴포넌트에서
 * { selectedRow, setSelectedRow }를 사용할 수 있습니다.
 */
export const SelectionProvider = ({ children }) => {
  const [selectedRow, setSelectedRow] = useState(null);

  return (
    <SelectionContext.Provider value={{ selectedRow, setSelectedRow }}>
      {children}
    </SelectionContext.Provider>
  );
};


----- C:\Users\pjw75\Desktop\react-prc\src\context\TimelineProvider.jsx -----

import React, { createContext, useRef } from "react";

/**
 * TimelineProvider: 여러 타임라인 인스턴스(vis-timeline 객체)를 공유 관리하는 컨텍스트입니다.
 * - poolRef: 타임라인 인스턴스(객체)들의 배열을 참조 (동기화, 해제 등에서 사용)
 * - register: 타임라인 생성 시 pool에 추가
 * - unregister: 타임라인 파괴 시 pool에서 제거
 */
export const TimelineContext = createContext(null);

export const TimelineProvider = ({ children }) => {
  // 타임라인 인스턴스(객체)들의 배열 (리렌더에도 값 유지)
  const poolRef = useRef([]);

  // 타임라인 인스턴스 추가
  const register = (tl) => (poolRef.current = [...poolRef.current, tl]);
  // 타임라인 인스턴스 제거
  const unregister = (tl) =>
    (poolRef.current = poolRef.current.filter((t) => t !== tl));

  return (
    <TimelineContext.Provider value={{ poolRef, register, unregister }}>
      {children}
    </TimelineContext.Provider>
  );
};


----- C:\Users\pjw75\Desktop\react-prc\src\hooks\useCTTTMLog.js -----

import { useQuery } from "@tanstack/react-query";
import * as api from "../api/historyAPI";

/**
 * 선택된 EQP의 CTTTM 로그 데이터를 불러오는 훅.
 * - eqpId가 있을 때만 동작
 * - 캐시 유지 시간: 30분
 */
export const useCtttmLog = (eqpId) =>
  useQuery({
    queryKey: ["ctttm", eqpId],
    queryFn: () => api.fetchCTTTMLog(eqpId).then((r) => r.data),
    enabled: !!eqpId,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\react-prc\src\hooks\useEqpStatusLog.js -----

import { useQuery } from "@tanstack/react-query";
import * as api from "../api/historyAPI";

/**
 * 선택된 EQP의 가동 상태(RUN) 데이터를 불러오는 훅.
 * - eqpId가 있을 때만 동작
 * - 캐시 유지 시간: 30분
 */
export const useEqpStatusLog = (eqpId) =>
  useQuery({
    queryKey: ["run", eqpId],
    queryFn: () => api.fetchEQPStatus(eqpId).then((r) => r.data),
    enabled: !!eqpId,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\react-prc\src\hooks\useLineQueries.js -----

import { useQuery } from "@tanstack/react-query";
import * as api from "../api/historyAPI";

/**
 * 전체 "라인 목록"을 불러오는 훅.
 * - 캐시 유지 시간: 30분
 */
export const useLines = () =>
  useQuery({
    queryKey: ["lines"],
    queryFn: () => api.fetchLines().then((r) => r.data),
    staleTime: 1000 * 60 * 30,
  });

/**
 * 선택된 라인의 "설비(EQP) 목록"을 불러오는 훅.
 * - enabled: 라인ID가 있을 때만 동작
 * - 캐시 유지 시간: 30분
 */
export const useEquipments = (lineId, sdwtId, enabled) =>
  useQuery({
    queryKey: ["equipments", lineId, sdwtId],
    queryFn: () => api.fetchEquipments(lineId, sdwtId).then((r) => r.data),
    enabled,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\react-prc\src\hooks\useRACBLog.js -----

import { useQuery } from "@tanstack/react-query";
import * as api from "../api/historyAPI";

/**
 * 선택된 EQP의 EVENT 로그 데이터를 불러오는 커스텀 훅.
 * - eqpId가 있을 때만 동작 (enabled: !!eqpId)
 * - 캐시 유지 시간: 30분
 */
export const useRacbLog = (eqpId) =>
  useQuery({
    queryKey: ["event", eqpId],
    queryFn: () => api.fetchRACBLog(eqpId).then((r) => r.data),
    enabled: !!eqpId,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\react-prc\src\hooks\useSDWTQueries.js -----

import { useQuery } from "@tanstack/react-query";
import * as api from "../api/historyAPI";

export const useSDWTQueries = (lineId) =>
  useQuery({
    queryKey: ["sdwt", lineId],
    queryFn: () => api.fetchSDWT(lineId).then((r) => r.data),
    enabled: !!lineId,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\react-prc\src\hooks\useTIPLog.js -----

import { useQuery } from "@tanstack/react-query";
import * as api from "../api/historyAPI";

/**
 * 선택된 EQP의 공정 단계(STEP) 데이터를 불러오는 훅.
 * - eqpId가 있을 때만 동작
 * - 캐시 유지 시간: 30분
 */
export const useTipLog = (eqpId) =>
  useQuery({
    queryKey: ["step", eqpId],
    queryFn: () => api.fetchTIPLog(eqpId).then((r) => r.data),
    enabled: !!eqpId,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\react-prc\src\pages\TimelinePage.jsx -----

// src/pages/TimelinePage.jsx
import React, { useState, useMemo } from "react";
import LineSelector from "../components/selectors/LineSelector";
import EqpSelector from "../components/selectors/EqpSelector";
import TimelineBoard from "../components/timeline/TimelineBoard";
import CombinedDataTable from "../components/tables/CombinedDataTable";
import LoadingSpinner from "../components/common/LoadingSpinner";
import { useEqpStatusLog } from "../hooks/useEqpStatusLog";
import { useTipLog } from "../hooks/useTIPLog";
import { useRacbLog } from "../hooks/useRacbLog";
import { useCtttmLog } from "../hooks/useCTTTMLog";
import { ChartBarIcon } from "@heroicons/react/24/outline";
import SDWTSelector from "../components/selectors/SDWTSelector";

const DATA_TYPES = {
  EQP: "EQP_LOG",
  TIP: "TIP_LOG",
  RACB: "RACB_LOG",
  CTTTM: "CTTTM_LOG",
};

const TimelinePage = () => {
  const [lineId, setLineId] = useState(null);
  const [eqpId, setEqpId] = useState(null);
  const [sdwtId, setSdwtId] = useState(null);
  const [typeFilters, setTypeFilters] = useState({
    [DATA_TYPES.EQP]: true,
    [DATA_TYPES.TIP]: true,
    [DATA_TYPES.RACB]: true,
    [DATA_TYPES.CTTTM]: true,
  });

  const { data: runData = [], isLoading: l1 } = useEqpStatusLog(eqpId);
  const { data: stepData = [], isLoading: l2 } = useTipLog(eqpId);
  const { data: eventData = [], isLoading: l3 } = useRacbLog(eqpId);
  const { data: ctttmData = [], isLoading: l4 } = useCtttmLog(eqpId); // ⬅️ 추가
  const isLoading = l1 || l2 || l3 || l4;

  const combinedAndSortedData = useMemo(() => {
    if (isLoading || !eqpId) return [];

    const transformedRun = runData.map((item) => ({
      id: `${DATA_TYPES.EQP}-${new Date(item.timestamp).toISOString()}`,
      originalTimestamp: new Date(item.timestamp),
      displayTimestamp: new Date(item.timestamp).toLocaleString(),
      type: DATA_TYPES.EQP,
      info1: item.status,
      info2: "",
      info3: "",
    }));

    const transformedStep = stepData.map((item) => ({
      id: `${DATA_TYPES.TIP}-${new Date(item.start_time).toISOString()}`,
      originalTimestamp: new Date(item.start_time),
      displayTimestamp: new Date(item.start_time).toLocaleString(),
      type: DATA_TYPES.TIP,
      info1: item.step,
      info2: item.ppid,
      info3: item.state,
    }));

    const transformedEvent = eventData.map((item) => ({
      id: `${DATA_TYPES.RACB}-${new Date(item.occurred_at).toISOString()}`,
      originalTimestamp: new Date(item.occurred_at),
      displayTimestamp: new Date(item.occurred_at).toLocaleString(),
      type: DATA_TYPES.RACB,
      info1: item.event_type,
      info2: item.comment,
      info3: "",
    }));

    const transformedCTTTM = ctttmData.map((item) => ({
      id: `${DATA_TYPES.CTTTM}-${new Date(item.occurred_at).toISOString()}`,
      originalTimestamp: new Date(item.occurred_at),
      displayTimestamp: new Date(item.occurred_at).toLocaleString(),
      type: DATA_TYPES.CTTTM,
      info1: item.event_type,
      info2: item.comment,
      info3: "",
    }));

    const allData = [
      ...transformedRun,
      ...transformedStep,
      ...transformedEvent,
      ...transformedCTTTM, // ✅ 추가
    ];

    allData.sort((a, b) => b.originalTimestamp - a.originalTimestamp);
    return allData;
  }, [runData, stepData, eventData, isLoading, eqpId]);

  const filteredData = useMemo(() => {
    return combinedAndSortedData.filter((item) => typeFilters[item.type]);
  }, [combinedAndSortedData, typeFilters]);

  const handleFilterChange = (event) => {
    const { name, checked } = event.target;
    setTypeFilters((prev) => ({ ...prev, [name]: checked }));
  };

  return (
    <div className="flex flex-col lg:flex-row h-[calc(100vh-120px)] gap-4 mt-4">
      {/* 좌측: 필터/선택/테이블 포함 */}
      <div className="lg:w-[40%] flex flex-col gap-4 h-full">
        {/* 상단 UI (타이틀 + 선택기 + 체크박스) */}
        <div className="p-4 bg-white dark:bg-slate-800 shadow rounded-xl">
          <h2 className="text-lg font-bold mb-3 text-slate-900 dark:text-white">
            📊 EQP 타임라인 뷰어
          </h2>
          <div className="grid grid-cols-3 gap-2 mb-2">
            <LineSelector lineId={lineId} setLineId={setLineId} />
            <SDWTSelector
              lineId={lineId}
              sdwtId={sdwtId}
              setSdwtId={setSdwtId}
            />
            <EqpSelector
              lineId={lineId}
              sdwtId={sdwtId}
              eqpId={eqpId}
              setEqpId={setEqpId}
            />
          </div>
          <div className="flex gap-3 flex-wrap">
            {Object.keys(DATA_TYPES).map((typeKey) => (
              <label
                key={typeKey}
                className="flex items-center gap-1 text-sm text-slate-700 dark:text-slate-300"
              >
                <input
                  type="checkbox"
                  name={DATA_TYPES[typeKey]}
                  checked={typeFilters[DATA_TYPES[typeKey]]}
                  onChange={handleFilterChange}
                  className="rounded border-gray-300 dark:border-slate-600"
                />
                {typeKey}
              </label>
            ))}
          </div>
        </div>

        {/* 통합 로그 테이블 */}
        <div className="flex-1 overflow-auto bg-white dark:bg-slate-800 shadow rounded-xl p-3">
          {eqpId && !isLoading ? (
            <CombinedDataTable data={filteredData} />
          ) : !eqpId ? (
            <p className="text-center text-slate-600 dark:text-slate-400">
              EQP를 선택하세요.
            </p>
          ) : (
            <LoadingSpinner />
          )}
        </div>
      </div>

      {/* 우측: 타임라인 전체 사용 */}
      <div className="lg:w-[60%] h-full overflow-auto bg-white dark:bg-slate-800 shadow rounded-xl p-4">
        {eqpId && !isLoading ? (
          <TimelineBoard eqpId={eqpId} />
        ) : !eqpId ? (
          <p className="text-center text-slate-600 dark:text-slate-400 py-20">
            타임라인을 표시하려면 EQP를 선택하세요.
          </p>
        ) : (
          <LoadingSpinner />
        )}
      </div>
    </div>
  );
};

export default TimelinePage;


----- C:\Users\pjw75\Desktop\react-prc\src\styles\timeline.css -----

@import "tailwindcss";

/* vis-timeline용 커스텀 스타일링 */
/* 전체 타임라인 영역 기본 마진 */
.timeline-container {
  margin-bottom: 16px;
}

/* 각 vis-item(타임라인 아이템)에 Tailwind 색상 스타일 적용 */
.vis-item {
  @apply border border-transparent;
  color: #334155; /* slate-800 */
  border-radius: 0 !important;
  margin-right: -1px;
  box-shadow: none !important;
}

/* 주요 상태별 색상 (Tailwind 색상 기준, groupConfig와 일치시켜야 함) */
.vis-item.bg-red-500    { @apply bg-red-500 border-red-600; }
.vis-item.bg-green-500  { @apply bg-green-500 border-green-600; }
.vis-item.bg-blue-500   { @apply bg-blue-500 border-blue-600; }
.vis-item.bg-yellow-500 { @apply bg-yellow-500 border-yellow-600; }
.vis-item.bg-gray-300   { @apply bg-gray-300 border-gray-400; }
.vis-item.bg-red-600    { @apply bg-red-600 border-red-700; }
.vis-item.bg-blue-600   { @apply bg-blue-600 border-blue-700; }
.vis-item.bg-yellow-600 { @apply bg-yellow-600 border-yellow-700; }
.vis-item.bg-green-600  { @apply bg-green-600 border-green-700; }
.vis-item.bg-amber-600  { @apply bg-amber-600 border-amber-700; }

/* 다크모드에서 아이템 텍스트 색상 */
.dark .vis-item {
  color: #f1f5f9; /* slate-100 */
}

/* 다크모드: 시간축(라벨/텍스트) 색상 */
.dark .vis-time-axis .vis-text,
.dark .vis-time-axis .vis-label {
  color: #f1f5f9 !important;
}

/* 라이트모드(기본) 시간축 색상 */
.vis-time-axis .vis-text,
.vis-time-axis .vis-label {
  color: #334155;
}

/* 선택된 아이템(클릭 시 강조) */
.vis-item.selected {
  @apply border-2 border-amber-500;
  z-index: 10;
}

/* 이미 있는 .vis-item.selected 밑에 바로 이어서 넣어 주세요 */
.vis-item.vis-range.selected {
  outline: 3px dashed #fb923c !important;  /* amber-400 */
  outline-offset: -1px;
  filter: brightness(1.2);                 /* 살짝 강조 */
}


.vis-time-axis .vis-text,
.vis-time-axis .vis-label {
  font-size: 13px !important;
}

/* 다크모드에서 타임라인 그룹 이름(라벨)을 흰색으로 */
.dark .vis-time-axis .vis-text,
.dark .vis-time-axis .vis-label {
  color: #f1f5f9 !important;
}

.dark .vis-group .vis-label,
.dark .vis-group .vis-inner {
  color: #f1f5f9 !important;
}

/* 기본 */
.vis-label.custom-group-label {
  color: #334155; /* slate-800 */
}

/* 다크모드 */
.dark .vis-label.custom-group-label {
  color: #f1f5f9 !important; /* slate-100 */
}




----- C:\Users\pjw75\Desktop\react-prc\src\utils\timelineMeta.js -----

/**
 * 타임라인 그룹별로 "옵션/색상/주요 컬럼"을 정의한 메타데이터 객체입니다.
 * - groupConfig[KEY]
 *    - type: "range" | "point"
 *    - options: vis-timeline에 넘길 옵션(기본값)
 *    - stateColors: 각 상태별 Tailwind 색상 클래스
 *    - columns: 시간, 상태, 설명(코멘트) 컬럼명
 */
export const groupConfig = {
  EQP_LOG: {
    type: "range",
    options: {},
    stateColors: {
      RUN: "bg-blue-600 border-blue-700",
      IDLE: "bg-yellow-600 border-yellow-700",
      PM: "bg-green-600 border-green-700",
      DOWN: "bg-red-600 border-red-700",
    },
    columns: {
      time: "timestamp",
      state: "status",
      comment: "status",
    },
  },
  TIP_LOG: {
    type: "range",
    options: {},
    stateColors: {
      OPEN: "bg-blue-600 border-blue-700",
      CLOSE: "bg-red-600 border-red-700",
    },
    columns: {
      time: "start_time",
      state: "state",
      comment: "step",
    },
  },
  RACB_LOG: {
    type: "point",
    options: {},
    stateColors: {
      ALARM: "bg-red-600 border-red-700",
      WARN: "bg-amber-600 border-amber-700",
    },
    columns: {
      time: "occurred_at",
      state: "event_type",
      comment: "comment",
    },
  },
  CTTTM_LOG: {
    type: "point",
    options: {},
    stateColors: {
      TTM_FAIL: "bg-red-600 border-red-700",
      TTM_WARN: "bg-yellow-600 border-yellow-700",
    },
    columns: {
      time: "occurred_at",
      state: "event_type",
      comment: "comment",
    },
  },
};


----- C:\Users\pjw75\Desktop\react-prc\src\utils\timelineUtils.js -----

import { groupConfig } from "./timelineMeta";

/**
 * 원시 데이터를 vis-timeline이 이해할 수 있는 형태로 가공합니다.
 * groupKey: 어떤 타입인지 (예: EQP_STATUS)
 * data: 원본 데이터 배열
 * overallMaxTime: 마지막 아이템 끝 범위 (없으면 range.max)
 */
export const processData = (groupKey, data) => {
  /**
   * 아이템 id는 groupKey-유니크값(timestamp 등)으로 생성해야
   * 테이블-타임라인 연동이 100% 일치합니다!
   */
  const cfg = groupConfig[groupKey];
  const { columns, stateColors } = cfg;

  return data
    .filter((row) => row && row[columns.time]) // <-- 이 한 줄 추가!
    .map((row) => {
      const start = new Date(row[columns.time]);
      const next = data[data.indexOf(row) + 1];
      // 마지막 아이템은 range.max까지 끝이 연장됩니다.
      const end = next
        ? new Date(next[columns.time])
        : new Date(
            start.getFullYear(),
            start.getMonth(),
            start.getDate(),
            23,
            59,
            59
          );
      const state = row[columns.state];
      const colorCls = stateColors[state] ?? "bg-gray-300";
      const groupId =
        columns.groupBy && row[columns.groupBy]
          ? row[columns.groupBy]
          : groupKey;

      return {
        id: `${groupKey}-${new Date(row[columns.time]).toISOString()}`,
        group: groupId,
        content: cfg.type === "range" ? undefined : row[columns.comment],
        start,
        end: cfg.type === "range" ? end : undefined,
        type: cfg.type,
        className: colorCls,
      };
    });
};

/**
 * ±3일 여유를 주는 범위 반환
 */
export const addBuffer = (min, max) => {
  const B = 3 * 24 * 60 * 60 * 1000;
  return { min: new Date(min - B), max: new Date(max + B) };
};

/**
 * 기본 타임라인 옵션
 */
export const baseOptions = (min, max) => ({
  stack: false,
  zoomMin: 1000 * 60 * 30,
  zoomMax: 1000 * 60 * 60 * 24 * 7,
  min,
  max,
});

/**
 * 여러 데이터(run/step/ev)에서 전체 시간 범위(min~max)를 계산합니다.
 */
export const calcRange = (...arrs) => {
  const ts = arrs
    .flat()
    .map((d) =>
      new Date(d.timestamp || d.start_time || d.occurred_at).getTime()
    );
  if (ts.length === 0) return { min: new Date(), max: new Date() };
  const min = new Date(Math.min(...ts));
  const max = new Date(Math.max(...ts));
  return { min, max };
};


----- C:\Users\pjw75\Desktop\react-prc\src\App.css -----


----- C:\Users\pjw75\Desktop\react-prc\src\App.jsx -----

import React from "react";
import { Routes, Route } from "react-router-dom";
import Navbar from "./components/common/Navbar";
import TimelinePage from "./pages/TimelinePage";

/**
 * 앱의 메인 컴포넌트입니다.
 * - 항상 상단에 Navbar(네비게이션 바)를 보여줍니다.
 * - / (홈) 및 /timeline (타임라인 페이지) 라우팅을 지원합니다.
 */
const HomePage = () => (
  <div className="p-6 text-center">
    <h1 className="text-2xl font-bold">홈페이지에 오신 것을 환영합니다!</h1>
    <p>네비게이션 바에서 타임라인 탭을 선택하여 EQP 타임라인을 확인하세요.</p>
  </div>
);

function App() {
  return (
    <div className="h-screen flex flex-col overflow-hidden">
      {/* 항상 상단에 표시되는 네비게이션 바 */}
      <Navbar />
      {/* 아래쪽 영역(페이지 본문) */}
      <div className="flex-1 overflow-hidden px-6">
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/timeline" element={<TimelinePage />} />
        </Routes>
      </div>
    </div>
  );
}

export default App;


----- C:\Users\pjw75\Desktop\react-prc\src\index.css -----

@import "tailwindcss";

/* Tailwind의 dark 모드 스타일 활성화 및 timeline.css 커스텀 스타일 불러오기 */
@custom-variant dark (&:where(.dark, .dark *));
@import "./styles/timeline.css";


/* 🔹 공통: 슬림 스크롤바 디자인 */
.table-scroll::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  
  /* 🔸 기본(라이트모드) 스타일 */
  .table-scroll::-webkit-scrollbar-track {
    background-color: #e2e8f0; /* slate-200 */
    border-radius: 10px;
  }
  .table-scroll::-webkit-scrollbar-thumb {
    background-color: #94a3b8; /* slate-400 */
    border-radius: 10px;
    border: 1px solid #e2e8f0;
  }
  
  /* 🔸 다크모드 스타일 */
  .dark .table-scroll::-webkit-scrollbar-track {
    background-color: #1e293b; /* slate-800 */
  }
  .dark .table-scroll::-webkit-scrollbar-thumb {
    background-color: #475569; /* slate-600 */
    border: 1px solid #1e293b;
  }
  
  /* 🔸 호버 시 더 진하게 */
  .dark .table-scroll::-webkit-scrollbar-thumb:hover {
    background-color: #64748b; /* slate-500 */
  }
  

----- C:\Users\pjw75\Desktop\react-prc\src\main.jsx -----

import React from "react";
import { createRoot } from "react-dom/client";
import { StrictMode } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { TimelineProvider } from "./context/TimelineProvider";
import { BrowserRouter } from "react-router-dom";
import App from "./App";
import { SelectionProvider } from "./context/SelectionContext";
import "./index.css";

// React Query의 전역 클라이언트(캐시 등)
const qc = new QueryClient();

/**
 * 프로젝트의 최상위 엔트리포인트입니다.
 * - StrictMode: React 개발용 경고/검사를 강화합니다.
 * - QueryClientProvider: React Query 전역 상태 제공
 * - TimelineProvider: 타임라인 동기화 컨텍스트 제공
 * - BrowserRouter: 라우팅 기능 제공
 * - App: 실제 앱 화면 (Navbar 및 각 페이지)
 */
createRoot(document.getElementById("root")).render(
  <StrictMode>
    <QueryClientProvider client={qc}>
      <TimelineProvider>
        <SelectionProvider>
          <BrowserRouter>
            <App />
          </BrowserRouter>
        </SelectionProvider>
      </TimelineProvider>
    </QueryClientProvider>
  </StrictMode>
);


----- C:\Users\pjw75\Desktop\react-prc\eslint.config.js -----

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


----- C:\Users\pjw75\Desktop\react-prc\index.html -----

<!doctype html>
<html lang="en" class="bg-slate-50 dark:bg-slate-900">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/src/index.css" rel="stylesheet">
    <title>Vite + React + Timeline</title>
    <script>
      // 페이지 로드 시 브라우저 테마 또는 localStorage에 따라 다크모드 설정
      if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
    </script>
  </head>
  <body class="bg-slate-50 dark:bg-slate-900">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


----- C:\Users\pjw75\Desktop\react-prc\tailwind.config.js -----

// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  // darkMode: class 기반으로(수동 전환 지원)
  darkMode: "class",
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}", // src 내부의 모든 js/ts/jsx/tsx 파일 적용
  ],
  theme: {
    extend: {},
  },
  plugins: [require("@tailwindcss/forms")],
};


----- C:\Users\pjw75\Desktop\react-prc\vite.config.js -----

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

/**
 * Vite 개발 서버 및 플러그인 설정 파일
 */
export default defineConfig({
  plugins: [react(), tailwindcss()],
  server: {
    host: "0.0.0.0", // 네트워크 내 다른 기기에서 접속 허용
  },
});

